#!/bin/bash
#
### BEGIN INIT INFO
# Provides: minimega
# Required-Start:
# Required-Stop:
# Default-Start: 2 3 4 5
# Default-Stop: 0 1 6
# Short-Description: Manages minimega process
# Description: Auto-starts minimega on boot, allows more flexible monitoring and management of minimega daemon process.
### END INIT INFO

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

if [ "`id -un`" != "root" ]; then # if user running this script is not user 'root'
  echo "Must run as root"
  exit 1
fi

source /etc/minimega/minimega.conf 2> /dev/null # don't display "no file or directory" error message
if [ "$?" != "0" ] && [ "$1" != "" ] && [ "$1" != "install" ] && [ "$1" != "uninstall" ]; then # if we weren't able to import the conf file
  echo "Unable to import configuration file. Please 'install' first."
  exit 1
fi

install() {
  # ask for init script and conf file directory
  read -p "Directory containing init script and configuration file: [$SCRIPT_DIR] " -r
  if [[ $REPLY == "" ]]; then
    REPLY=$SCRIPT_DIR
  fi
  # locate init script and conf file
  if [ ! -f "$REPLY/minimega.init" ]; then
    echo "Cannot find init script at $REPLY/minimega.init"
    return 1
  fi
  if [ ! -f "$REPLY/minimega.conf" ]; then
    echo "Cannot find configuration at $REPLY/minimega.conf"
    return 1
  fi
  source "$REPLY/minimega.conf" 2> /dev/null # don't display "no file or directory" error message
  # create minimega directories
  log_dir=$(dirname $MM_LOG_FILE)
  mkdir -p $log_dir
  mkdir -p /etc/minimega/saved_vms/
  # create some links to 'install' the init script
  ln -s $REPLY/minimega.init /etc/init.d/minimega
  ln -s $REPLY/minimega.conf /etc/minimega/minimega.conf
  systemctl enable minimega # make 'start' run on boot
  return 0
}

uninstall() {
  unlink /etc/init.d/minimega
  unlink /etc/minimega/minimega.conf
  systemctl disable minimega
  log_dir=$(dirname $MM_LOG_FILE)
  echo "Uninstallation complete. The config directory (/etc/minimega) and log directory ($log_dir) were not removed."
}

update() {
  return 0
}

start() {
  check_if_running
  if [ "$?" == "0" ]; then # if there's already a process running
    old_pid=`cat $MM_RUN_PATH/minimega.pid 2> /dev/null`
    echo "minimega already running as pid $old_pid"
    return 1
  fi
  ulimit -n 1024000 -u 4096000
  mkdir -p $MM_RUN_PATH
  pushd $MINIMEGA_DIR &>/dev/null
  $MINIMEGA_DIR/bin/minimega -base=$MM_RUN_PATH -filepath=$MM_FILEPATH -degree=$MM_MESH_DEGREE -nostdin=$MM_DAEMON -context=$MM_CONTEXT -port=$MM_PORT -level=$MM_LOG_LEVEL -logfile=$MM_LOG_FILE ${@:1} &> /dev/null &
  popd &>/dev/null
  sleep 1
  new_pid=`cat $MM_RUN_PATH/minimega.pid 2> /dev/null`
  if [ "$?" != "0" ]; then # if the process has already died
    echo "minimega did not start"
    return 1
  fi
  # set minimega group permissions
  chgrp -R minimega $MM_RUN_PATH
  chmod -R g=u $MM_RUN_PATH
  chmod g+s $MM_RUN_PATH ${MM_RUN_PATH}/minimega
  echo "minimega started as process `cat $MM_RUN_PATH/minimega.pid`"
  return 0
}

stop() {
  check_if_running
  if [ "$?" != "0" ]; then # if it isn't running before we "stop" it
    echo "minimega is not running."
    return 1
  fi
  pid=`cat $MM_RUN_PATH/minimega.pid 2> /dev/null`
  kill $pid
  rm $MM_RUN_PATH/minimega.pid
  rm $MM_RUN_PATH/minimega
  echo "minimega stopped"
  return 0
}

status() {
  check_if_running
  if [ "$?" == "0" ]; then # if it is running
    pid=`cat $MM_RUN_PATH/minimega.pid 2> /dev/null`
    echo "minimega is running at pid $pid."
    return 0
  else
    echo "minimega is not running."
    return 1
  fi
}

recover() {
  check_if_running
  if [ "$?" == "0" ]; then # if it is running
    for save in /etc/minimega/saved_vms/*
    do
      echo "Recovering: "`basename "$save"`
      $MINIMEGA_DIR/bin/minimega -e read $save
    done
    echo "Done."
  else
    echo "minimega is not running."
    return 1
  fi
}

check_if_running() {
  pid=`cat $MM_RUN_PATH/minimega.pid 2> /dev/null`
  if [ "$?" == "0" ]; then # if it is supposed to be running
    check=`ps aux | grep minimega | grep $pid 2>/dev/null` # TODO: check for a minimega running with a different pid
    if [ "$?" == "0" ]; then # if it is running
      return 0
    else
      return 1
    fi
  else
    return 1
  fi
}


rtn=0
case "$1" in
  start)
    start ${@:2}
    rtn=$?
    ;;
  stop)
    stop
    rtn=$?
    ;;
  restart)
    stop
    start ${@:2}
    rtn=$?
    ;;
  status)
    status
    rtn=$?
    ;;
  update)
    update
    rtn=$?
    ;;
  install)
    install
    rtn=$?
    ;;
  uninstall)
    uninstall
    rtn=$?
    ;;
  recover)
    recover
    rtn=$?
    ;;
  *)
    echo "Usage: $0{start|stop|restart|status|update|install|uninstall|recover}"
    exit 1
    ;;
esac

if [ "$rtn" == "0" ]; then
  exit 0
else
  exit 1
fi


